#!/usr/bin/env bash

[[ "$1" = "-x" ]] && set -o xtrace && shift

calling_script="$1"

available_methods() {
    sed -n "s/^function _\(.*\)().*/\1/p" < "$1"
}

methods=("$(available_methods "$calling_script")")

function is_available() {
   [[ "${methods[*]}" =~ (^|[[:space:]])"${1:-}"($|[[:space:]]) ]]
}

# should break when there are no first or second variable and the first variable is an available method,
# and should continue if either first or second variable starts with dash
function should_continue_variables_loop() {
  if [[ ! "${1-}" ]]; then
    return 1  # no
  elif [[ "${1:0:1}" == '-' ]] || [[ "${2:0:1}" == '-' ]]; then
    return 0  # yes - may create issues if your args has dash as the first character
  elif [[ "${1:0:1}" != '-' ]] && [[ "${2:0:1}" != '-' ]]; then
    return 1  # yes - may create issues if your args has dash as the first character
  elif [[ ! "${2-}" ]]; then
    return 1  # no
  elif [[ -n "${command-}" ]] && is_available "$1" && [[ "${2:0:1}" != '-' ]]; then
    return 1  # no
  fi
  return 0  # yes
}

if [[ "${2-}" ]] && is_available "$2"; then
  command="$2"
  shift
fi

if [[ $# -gt 1 ]]; then
   # If the current pointer ($1) is a valid command (is an exported method from the source) or if it's the last variable (catch help and non-exported names)
  while	should_continue_variables_loop "$@" ; do
    # properties start with at least one dash
    if [ "${1:0:1}" == '-' ]; then
      OPTION="${1:1}"
      # but it may be two
      if [ "${OPTION:0:1}" == '-' ]; then
        OPTION="${OPTION:1}"
      fi
      #convert to snake_case
      #handle single variable e.g. -something=other
      if [[ $OPTION =~ = ]]; then
        OPTION_KEY=${OPTION/=*/}
	OPTION_KEY=${OPTION_KEY//-/_}
	#declare as screaming snake case with prefixed underscore
        declare "_${OPTION_KEY^^}=${OPTION/*=/}"
        if [[ ! "${2-}" ]] || { [[ "${1:0:1}" == '-' ]] && [[ "$1" =~ '=' ]] && [[ "${2:0:1}" != '-' ]] ;} then
          break
        fi
      else
        OPTION=${OPTION//-/_}
	#declare fallback screaming snake case and the next variable is the value..
	#flags will simply have the value of the next variable/or the command
        declare "_${OPTION^^}=${2-}"
      fi
    fi
    shift
  done
fi

# this is the method to print help-message from the given file (and this method) prints the content following the syntax below.
# will replace indices of _PROGRAM with the programs actual name
function _help() {  #HELP display this message:\n_PROGRAM help
    program_name=${1##*/}
    sed -n "s/^.*#HELP\\s//p;" < "$1" | sed "s/\\\\n/\n\t/g;s/$/\n/;s/_PROGRAM/$program_name/g"
    sed -n "s/^.*#HELP\\s//p;" < "$2" | sed "s/\\\\n/\n\t/g;s/$/\n/;s/_PROGRAM/$program_name/g"
}

if [[ -z "${command-}" ]] && is_available "${2-}"; then
  shift
fi

#Sources the given script and calls the metod referenced if it's exported, else _help
# shellcheck source=/dev/null
source "$calling_script"
command=${command:-$1}
if is_available "${command:-NoT#AMethod}"; then
    _"$command" "${@:2}"
else
    _help "$calling_script" "$0"
fi
