#!/usr/bin/env bash

[[ "$1" = "-x" ]] && set -o xtrace && shift

calling_script="$1"

available_methods() {
    sed -n "s/^function _\(.*\)().*/\1/p" < "$1"
}

methods=("$(available_methods "$calling_script")")

is_available() {
   [[ "${methods[*]}" =~ (^|[[:space:]])"${1:-}"($|[[:space:]]) ]]
}

if [[ "${2-}" ]] && is_available "$2"; then
  command="$2"
  shift
fi

option() {
  opt="$1"
  [[ "${opt:0:1}" = "-" ]] && opt="${opt:1}"  # support two dashes in front
  echo "_${opt//-/_}=$2"
}

while	(( $# )) ; do
  case "$1" in
  -*=*)
    opt_key="${1/=*/}"
    #declare with prefixed underscore
    declare "$(option "${opt_key:1}" "${1/*=/}")"
    ;;
  --)  # hidden feature should document - must have command before --
    break  # don't shift as wash calls "${@:2}"
    ;;
  -*)
    declare "$(option "${1:1}" "${2-}")"
    ;;
  *)
    { [[ ! "${2-}" ]] || [[ "${2:0:1}" != '-' ]] ;} && break
    { [[ ! "${command-}" ]] && is_available "$1" ;} && break
    ;;
  esac
  shift
done


# this is the method to print help-message from the given file (and this method) prints the content following the syntax below.
# will replace indices of _PROGRAM with the programs actual name
function _help() {  #HELP display this message:\n_PROGRAM help
    program_name=${1##*/}
    sed -n "s/^.*#HELP\\s//p;" < "$1" | sed "s/\\\\n/\n\t/g;s/$/\n/;s/_PROGRAM/$program_name/g"
    sed -n "s/^.*#HELP\\s//p;" < "$2" | sed "s/\\\\n/\n\t/g;s/$/\n/;s/_PROGRAM/$program_name/g"
}

if [[ -z "${command-}" ]] && is_available "${2-}"; then
  shift
fi

#Sources the given script and calls the method referenced if it's exported, else _help
# shellcheck source=/dev/null
source "$calling_script"
command="${command:-$1}"
if is_available "${command:-NoT#AMethod}"; then
    _"$command" "${@:2}"
else
    _help "$calling_script" "$0"
fi
